//! Activity log â€” in-memory ring buffer of recent observations for summarization

use serde::Serialize;
use std::collections::VecDeque;

/// A single activity entry recorded from observations
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct ActivityEntry {
    pub timestamp: u64,
    pub app_name: Option<String>,
    pub window_title: Option<String>,
    pub ocr_snippet: Option<String>,
    pub change_ratio: f64,
}

/// Activity summary generated by AI
#[derive(Debug, Clone, Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ActivitySummary {
    pub summary: String,
    pub period_start: u64,
    pub period_end: u64,
    pub entry_count: usize,
    pub top_apps: Vec<String>,
    pub generated_at: u64,
}

/// Ring buffer of activity entries
#[derive(Debug)]
pub struct ActivityLog {
    entries: VecDeque<ActivityEntry>,
    max_entries: usize,
    summaries: Vec<ActivitySummary>,
    max_summaries: usize,
}

impl Default for ActivityLog {
    fn default() -> Self {
        Self {
            entries: VecDeque::with_capacity(500),
            max_entries: 500,
            summaries: Vec::new(),
            max_summaries: 50,
        }
    }
}

impl ActivityLog {
    /// Add an activity entry from an observation
    pub fn push(&mut self, entry: ActivityEntry) {
        if self.entries.len() >= self.max_entries {
            self.entries.pop_front();
        }
        self.entries.push_back(entry);
    }

    /// Get entries within a time range
    pub fn entries_in_range(&self, start: u64, end: u64) -> Vec<&ActivityEntry> {
        self.entries
            .iter()
            .filter(|e| e.timestamp >= start && e.timestamp <= end)
            .collect()
    }

    /// Get all unsummarized entries (entries after the last summary period)
    pub fn pending_entries(&self) -> Vec<&ActivityEntry> {
        let last_summarized = self
            .summaries
            .last()
            .map(|s| s.period_end)
            .unwrap_or(0);

        self.entries
            .iter()
            .filter(|e| e.timestamp > last_summarized)
            .collect()
    }

    /// Get total entry count
    pub fn len(&self) -> usize {
        self.entries.len()
    }

    /// Store a generated summary
    pub fn add_summary(&mut self, summary: ActivitySummary) {
        if self.summaries.len() >= self.max_summaries {
            self.summaries.remove(0);
        }
        self.summaries.push(summary);
    }

    /// Get recent summaries
    pub fn recent_summaries(&self, count: usize) -> &[ActivitySummary] {
        let start = self.summaries.len().saturating_sub(count);
        &self.summaries[start..]
    }

    /// Build a text representation of entries for AI summarization
    pub fn format_for_ai(&self, entries: &[&ActivityEntry]) -> String {
        let mut lines = Vec::new();
        for entry in entries {
            let ts = chrono::DateTime::from_timestamp_millis(entry.timestamp as i64)
                .map(|dt| dt.format("%H:%M:%S").to_string())
                .unwrap_or_else(|| "??:??:??".to_string());

            let app = entry.app_name.as_deref().unwrap_or("Unknown");
            let title = entry.window_title.as_deref().unwrap_or("");
            let snippet = entry
                .ocr_snippet
                .as_deref()
                .unwrap_or("")
                .chars()
                .take(100)
                .collect::<String>();

            lines.push(format!("[{}] {} - {} | {}", ts, app, title, snippet));
        }
        lines.join("\n")
    }
}
